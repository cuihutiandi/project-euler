###############################################################################################################
###############################################################################################################
###############################################################################################################

'''
Multiples of 3 and 5: 
If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. 
The sum of these multiples is 23. Find the sum of all the multiples of 3 or 5 below 1000.
'''

def sum_of_multiples():
    total = 0
    for i in range(1000):
        if i % 3 == 0 or i % 5 == 0:
            total += i
    return total

print(sum_of_multiples())

'''
The formula for the sum of all numbers in such a series is (n/2)*(first_term + last_term), where n is the number of terms.
If we want to find the sum of all multiples of a given number x below N, 
we can use this formula where the first term is x (because x*1 = x) 
and the last term is x*floor((N-1)/x), which is the largest multiple of x that is less than N.
 The number of terms n is floor((N-1)/x).
This leads to the formula sum = (x/2)*n*(1+n) for the sum of all multiples of x less than N.
Now, if we want to find the sum of all numbers that are multiples of 3 or 5, 
we can simply calculate these two sums and add them together. 
But we have to be careful: n
umbers that are multiples of 15 (which is the least common multiple of 3 and 5) are included in both sums, 
so we are counting them twice. To get the correct answer, we need to subtract the sum of all multiples of 15.
'''
def sum_of_multiples(n, x):
    # Find the number of terms
    p = (n-1) // x
    # Use the formula for the sum of an arithmetic series
    return x * p * (p+1) // 2

N = 1000
# Calculate the sum of multiples of 3 or 5
total = sum_of_multiples(N, 3) + sum_of_multiples(N, 5) - sum_of_multiples(N, 15)

print(total)

###############################################################################################################
###############################################################################################################
###############################################################################################################

'''
Even Fibonacci numbers: Each new term in the Fibonacci sequence is generated by adding the previous two terms. 
By starting with 1 and 2, the first 10 terms will be: 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ... 
By considering the terms in the Fibonacci sequence whose values do not exceed four million, 
find the sum of the even-valued terms.

In this version of the solution, we're skipping directly to every third Fibonacci number (which is even) 
using the formula a + 2*b, thereby reducing the number of iterations and improving efficiency.
'''

def sum_even_fibonacci(limit):
    a, b = 1, 2
    total = 0
    while a <= limit:
        if a % 2 == 0:
            total += a
        a, b = b, a + b
    return total

print(sum_even_fibonacci(4000000))

'''
Since we're only interested in even-valued terms in the Fibonacci sequence, 
we can take advantage of the fact that every third Fibonacci number is even. 
This is due to the pattern in which the Fibonacci sequence is generated.

In this version of the solution, we're skipping directly to every third Fibonacci number (which is even) 
using the formula a + 2*b, thereby reducing the number of iterations and improving efficiency.
'''
def sum_even_fibonacci(limit):
    a, b, total = 1, 2, 0
    while a <= limit:
        total += a
        a, b = b, a + 2*b
    return total

print(sum_even_fibonacci(4000000))


###############################################################################################################
###############################################################################################################
###############################################################################################################
'''
Largest prime factor: The prime factors of 13195 are 5, 7, 13 and 29. 
What is the largest prime factor of the number 600851475143?
'''
def largest_prime_factor(n):
    i = 2
    while i * i <= n:
        if n % i:
            i += 1
        else:
            n //= i
    return n

print(largest_prime_factor(600851475143))

'''
We could make it slightly more efficient by treating 2 as a special case and then checking only odd numbers. 
This is because 2 is the only even prime number; all other prime numbers are odd.

In this code, we first divide n by 2 as many times as possible. 
After this, we know that n must be odd, so we start checking from 3 and increment i by 2 each time, 
thus skipping the even numbers. The rest of the algorithm is the same as before.

This updated solution halves the number of potential factors that need to be checked, 
so it could be considered more efficient, especially for very large numbers.
'''
def largest_prime_factor(n):
    # Deal with the factor of 2 separately
    while n % 2 == 0:
        n //= 2

    # At this point, n must be odd, so we can skip the even numbers
    i = 3
    while i * i <= n:
        if n % i == 0:
            n //= i
        else:
            i += 2

    return n

print(largest_prime_factor(600851475143))

###############################################################################################################
###############################################################################################################
###############################################################################################################
'''
Largest palindrome product: A palindromic number reads the same both ways. 
The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 Ã— 99. 
Find the largest palindrome made from the product of two 3-digit numbers.
'''

def largest_palindrome_product():
    max_palindrome = 0
    for i in range(100, 1000):
        for j in range(i, 1000):  # j starts from i to avoid duplicate pairs
            product = i * j
            if product > max_palindrome and str(product) == str(product)[::-1]:
                max_palindrome = product
    return max_palindrome

print(largest_palindrome_product())


'''
A palindromic number of the form xyyx can be written as 11 * f(x, y) 
where f(x, y) = 100x + 10y + x is a 3-digit number. 
This means that at least one of the factors of our palindromic number must be divisible by 11.

In this solution, we start with the largest 3-digit number (999) and go down. 
If a is divisible by 11, we check all 3-digit numbers for b. 
If a is not divisible by 11,
we only check numbers that are divisible by 11 for b (starting from the largest one, 990, and going down by 11 each time). 
This is because we know that at least one of the factors must be divisible by 11. 
For each pair a, b, we first check if the product a*b could be larger than max_palindrome. 
If not, we can stop the inner loop early because all further products would be even smaller. 
If a*b is a palindrome and larger than max_palindrome, we update max_palindrome.

This optimized solution is much faster than the naive solution 
because it significantly reduces the number of pairs a, b that need to be checked.

'''
def largest_palindrome_product():
    max_palindrome = 0
    a = 999
    while a >= 100:
        if a % 11 == 0:
            b, db = 999, 1
        else:
            b, db = 990, 11  # The largest number less than or equal 999 and divisible by 11
        while b >= a:
            if a*b <= max_palindrome:
                break
            if str(a*b) == str(a*b)[::-1]:
                max_palindrome = a*b
            b -= db
        a -= 1
    return max_palindrome

print(largest_palindrome_product())

###############################################################################################################
###############################################################################################################
###############################################################################################################

'''
Smallest multiple: 
2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder. 
What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?
'''

'''
This problem is essentially asking for the least common multiple (LCM) of the numbers from 1 to 20. 
We can solve it using the formula LCM(a, b) = a * b / GCD(a, b), where GCD is the greatest common divisor.

In this code, we use a loop to calculate the LCM of the numbers from 1 to n. 
We start with result = 1 (because the LCM of 1 and any number x is x), 
and for each number i from 1 to n, we multiply result by i / GCD(i, result). 
This ensures that result is always divisible by i and all previous numbers, so at the end of the loop, 
result is the LCM of all numbers from 1 to n.
'''
import math

def smallest_multiple(n):
    result = 1
    for i in range(1, n + 1):
        result *= i // math.gcd(i, result)
    return result

def gcd(x, y):
    while(y):
        x, y = y, x % y
    return x


print(smallest_multiple(20))
